#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tire Impedance Simulation Data Analyzer
Based on Ucaretron Inc. patent application: "Tire Condition Diagnostic System and Method Using Impedance Measurement"

This script analyzes simulated impedance data to detect anomalies and diagnose tire conditions:
- Reads CSV files generated by generate_simulation_data.py
- Applies data preprocessing (filtering, normalization)
- Detects anomalies using statistical methods
- Generates visualizations and diagnostic reports
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
import matplotlib.dates as mdates
from datetime import datetime
import argparse
import glob
from enum import Enum, auto
from collections import deque


class AnomalyType(Enum):
    """Enumeration of different types of tire anomalies that can be detected."""
    NORMAL = auto()
    GRADUAL_WEAR = auto()      # Normal wear process
    ACCELERATED_WEAR = auto()  # Faster than normal wear
    SIDEWALL_DAMAGE = auto()   # Damage to the sidewall structure
    TREAD_DAMAGE = auto()      # Damage to the tread
    BEAD_DAMAGE = auto()       # Damage near the bead
    PUNCTURE = auto()          # Possible puncture
    UNEVEN_WEAR = auto()       # Uneven wear pattern
    TEMPERATURE_ISSUE = auto() # Abnormal temperature
    UNKNOWN = auto()           # Unclassified anomaly


class AlertLevel(Enum):
    """Enumeration of different alert severity levels."""
    INFO = auto()        # Informational alerts, no immediate action needed
    ADVISORY = auto()    # Advisory alerts suggesting future maintenance
    WARNING = auto()     # Warning alerts requiring attention soon
    CRITICAL = auto()    # Critical alerts requiring immediate attention
    EMERGENCY = auto()   # Emergency alerts requiring immediate stop


class TireDataAnalyzer:
    """
    Analyzes tire impedance data to detect anomalies and diagnose conditions.
    
    Attributes:
        data (pandas.DataFrame): Tire impedance data
        thresholds (dict): Thresholds for anomaly detection
        window_size (int): Size of the sliding window for analysis
    """
    
    def __init__(self, data=None, window_size=10):
        """
        Initialize the tire data analyzer.
        
        Args:
            data (pandas.DataFrame, optional): Tire impedance data
            window_size (int): Size of the sliding window for analysis
        """
        self.data = data
        self.window_size = window_size
        
        # Set thresholds for anomaly detection
        self.thresholds = {
            'tread_left': {
                'absolute_high': 1.3,    # Threshold for immediate alert
                'rate_high': 0.02,       # High rate of change
                'wear_rate_normal': 0.005 # Normal wear rate
            },
            'tread_right': {
                'absolute_high': 1.3,
                'rate_high': 0.02,
                'wear_rate_normal': 0.005
            },
            'sidewall': {
                'absolute_high': 1.4,    # Sidewall damage threshold
                'rate_high': 0.03,       # Rapid change indicates potential damage
                'wear_rate_normal': 0.003
            },
            'bead': {
                'absolute_high': 1.2,    # Bead area is more sensitive
                'rate_high': 0.01,
                'wear_rate_normal': 0.002
            },
            'temperature_high': 65.0,
            'temperature_low': 5.0
        }
        
        # Initialize data storage for analysis
        self.normalized_data = None
        self.anomalies = []
        self.alerts = []
        
        # Mapping from locations to display names
        self.location_names = {
            'tread_left': 'Tread (Left)',
            'tread_right': 'Tread (Right)',
            'sidewall': 'Sidewall',
            'bead': 'Bead'
        }
        
        # Mapping from anomaly types to alert levels
        self.anomaly_to_alert_level = {
            AnomalyType.NORMAL: AlertLevel.INFO,
            AnomalyType.GRADUAL_WEAR: AlertLevel.INFO,
            AnomalyType.ACCELERATED_WEAR: AlertLevel.ADVISORY,
            AnomalyType.SIDEWALL_DAMAGE: AlertLevel.CRITICAL,
            AnomalyType.TREAD_DAMAGE: AlertLevel.WARNING,
            AnomalyType.BEAD_DAMAGE: AlertLevel.CRITICAL,
            AnomalyType.PUNCTURE: AlertLevel.EMERGENCY,
            AnomalyType.UNEVEN_WEAR: AlertLevel.ADVISORY,
            AnomalyType.TEMPERATURE_ISSUE: AlertLevel.WARNING,
            AnomalyType.UNKNOWN: AlertLevel.WARNING
        }
    
    def load_data(self, file_path):
        """
        Load impedance data from a CSV file.
        
        Args:
            file_path (str): Path to the CSV file
            
        Returns:
            pandas.DataFrame: Loaded data
        """
        try:
            self.data = pd.read_csv(file_path)
            print(f"Loaded data from {file_path}")
            print(f"Data shape: {self.data.shape}")
            
            # Convert timestamp to datetime if it's not already
            if 'timestamp' in self.data.columns and not pd.api.types.is_datetime64_dtype(self.data['timestamp']):
                self.data['timestamp'] = pd.to_datetime(self.data['timestamp'])
            
            return self.data
        except Exception as e:
            print(f"Error loading data: {e}")
            return None
    
    def preprocess_data(self):
        """
        Preprocess the data for analysis.
        
        Returns:
            pandas.DataFrame: Preprocessed data
        """
        if self.data is None:
            print("No data to preprocess. Please load data first.")
            return None
        
        # Initialize normalized data frame
        normalized_data = self.data.copy()
        
        # Get base impedance values
        base_impedance = {}
        
        for sensor_id in range(1, 5):
            # Get the first few readings for baseline (assuming no damage in beginning)
            start_idx = 0
            end_idx = min(10, len(self.data))
            
            col_name = f'sensor_{sensor_id}_impedance'
            location_col = f'sensor_{sensor_id}_location'
            
            if col_name in self.data.columns:
                base_values = self.data.iloc[start_idx:end_idx][col_name].values
                base_impedance[sensor_id] = np.mean(base_values)
                
                # Normalize impedance values
                normalized_data[f'sensor_{sensor_id}_normalized'] = (
                    self.data[col_name] / base_impedance[sensor_id]
                )
        
        self.normalized_data = normalized_data
        return normalized_data
    
    def detect_anomalies(self):
        """
        Detect anomalies in the preprocessed data.
        
        Returns:
            list: List of detected anomalies
        """
        if self.normalized_data is None:
            print("No preprocessed data. Please preprocess data first.")
            return []
        
        anomalies = []
        
        # Iterate through each time step
        for i, row in self.normalized_data.iterrows():
            time_step = row['time_step']
            timestamp = row['timestamp']
            
            # Check each sensor
            for sensor_id in range(1, 5):
                # Get relevant data
                normalized_col = f'sensor_{sensor_id}_normalized'
                location_col = f'sensor_{sensor_id}_location'
                temp_col = f'sensor_{sensor_id}_temperature'
                
                if normalized_col not in row or location_col not in row:
                    continue
                
                normalized_value = row[normalized_col]
                location = row[location_col]
                temperature = row[temp_col] if temp_col in row else 25.0  # Default temp
                
                # Skip if missing data
                if pd.isna(normalized_value) or pd.isna(location):
                    continue
                
                # Check absolute thresholds
                threshold = self.thresholds.get(location, {}).get('absolute_high', 1.3)
                
                # Check temperature thresholds
                if temperature > self.thresholds['temperature_high']:
                    anomalies.append({
                        'time_step': time_step,
                        'timestamp': timestamp,
                        'sensor_id': sensor_id,
                        'location': location,
                        'value': normalized_value,
                        'temperature': temperature,
                        'anomaly_type': AnomalyType.TEMPERATURE_ISSUE,
                        'confidence': min(1.0, (temperature - self.thresholds['temperature_high']) / 10.0),
                        'details': f"High temperature detected: {temperature:.1f}°C"
                    })
                    continue
                
                if temperature < self.thresholds['temperature_low']:
                    anomalies.append({
                        'time_step': time_step,
                        'timestamp': timestamp,
                        'sensor_id': sensor_id,
                        'location': location,
                        'value': normalized_value,
                        'temperature': temperature,
                        'anomaly_type': AnomalyType.TEMPERATURE_ISSUE,
                        'confidence': min(1.0, (self.thresholds['temperature_low'] - temperature) / 10.0),
                        'details': f"Low temperature detected: {temperature:.1f}°C"
                    })
                    continue
                
                # Check impedance thresholds
                if normalized_value > threshold:
                    # Determine type of anomaly based on sensor location
                    if location == 'sidewall':
                        anomaly_type = AnomalyType.SIDEWALL_DAMAGE
                        details = "Potential sidewall damage detected"
                    elif location.startswith('tread'):
                        anomaly_type = AnomalyType.TREAD_DAMAGE
                        details = "Potential tread damage detected"
                    elif location == 'bead':
                        anomaly_type = AnomalyType.BEAD_DAMAGE
                        details = "Potential bead area issue detected"
                    else:
                        anomaly_type = AnomalyType.UNKNOWN
                        details = "Unknown anomaly detected"
                    
                    # Calculate confidence based on how far above threshold
                    confidence = min(1.0, (normalized_value - threshold) / threshold)
                    
                    anomalies.append({
                        'time_step': time_step,
                        'timestamp': timestamp,
                        'sensor_id': sensor_id,
                        'location': location,
                        'value': normalized_value,
                        'temperature': temperature,
                        'anomaly_type': anomaly_type,
                        'confidence': confidence,
                        'details': details
                    })
                
                # Check rate of change if we have enough history
                if i >= self.window_size:
                    # Calculate rate of change
                    prev_value = self.normalized_data.iloc[i-self.window_size][normalized_col]
                    rate = (normalized_value - prev_value) / self.window_size
                    
                    rate_threshold = self.thresholds.get(location, {}).get('rate_high', 0.02)
                    
                    if rate > rate_threshold:
                        # Determine type of anomaly based on sensor location
                        if location == 'sidewall':
                            anomaly_type = AnomalyType.SIDEWALL_DAMAGE
                            details = "Rapid sidewall impedance change detected"
                        elif location.startswith('tread'):
                            anomaly_type = AnomalyType.ACCELERATED_WEAR
                            details = "Accelerated tread wear detected"
                        elif location == 'bead':
                            anomaly_type = AnomalyType.BEAD_DAMAGE
                            details = "Rapid bead area impedance change detected"
                        else:
                            anomaly_type = AnomalyType.UNKNOWN
                            details = "Rapid impedance change detected"
                        
                        # Calculate confidence based on rate
                        confidence = min(1.0, rate / (rate_threshold * 2))
                        
                        anomalies.append({
                            'time_step': time_step,
                            'timestamp': timestamp,
                            'sensor_id': sensor_id,
                            'location': location,
                            'value': normalized_value,
                            'temperature': temperature,
                            'anomaly_type': anomaly_type,
                            'confidence': confidence,
                            'details': details
                        })
        
        # Check for uneven wear between tread sensors
        tread_left_data = self.normalized_data[self.normalized_data[f'sensor_1_location'] == 'tread_left']
        tread_right_data = self.normalized_data[self.normalized_data[f'sensor_2_location'] == 'tread_right']
        
        if not tread_left_data.empty and not tread_right_data.empty:
            # Compare last values
            left_last = tread_left_data.iloc[-1][f'sensor_1_normalized']
            right_last = tread_right_data.iloc[-1][f'sensor_2_normalized']
            
            diff_ratio = abs(left_last - right_last) / max(left_last, right_last)
            
            # If significant difference, report uneven wear
            if diff_ratio > 0.15:  # More than 15% difference
                # Determine which side is wearing faster
                higher_side = 1 if left_last > right_last else 2
                higher_location = 'tread_left' if higher_side == 1 else 'tread_right'
                
                # Get the last timestamp and time_step
                last_row = self.normalized_data.iloc[-1]
                
                anomalies.append({
                    'time_step': last_row['time_step'],
                    'timestamp': last_row['timestamp'],
                    'sensor_id': higher_side,
                    'location': higher_location,
                    'value': left_last if higher_side == 1 else right_last,
                    'temperature': last_row[f'sensor_{higher_side}_temperature'],
                    'anomaly_type': AnomalyType.UNEVEN_WEAR,
                    'confidence': min(1.0, diff_ratio / 0.3),
                    'details': f"Uneven tread wear detected ({diff_ratio:.2%} difference)"
                })
        
        self.anomalies = anomalies
        return anomalies
    
    def generate_alerts(self):
        """
        Generate alerts based on detected anomalies.
        
        Returns:
            list: List of generated alerts
        """
        if not self.anomalies:
            print("No anomalies detected. No alerts generated.")
            return []
        
        alerts = []
        
        for anomaly in self.anomalies:
            # Determine alert level based on anomaly type and confidence
            anomaly_type = anomaly['anomaly_type']
            confidence = anomaly['confidence']
            
            # Get base alert level for this anomaly type
            base_level = self.anomaly_to_alert_level.get(anomaly_type, AlertLevel.WARNING)
            
            # Create alert
            alert = {
                'timestamp': anomaly['timestamp'],
                'time_step': anomaly['time_step'],
                'sensor_id': anomaly['sensor_id'],
                'location': anomaly['location'],
                'anomaly_type': anomaly_type,
                'confidence': confidence,
                'alert_level': base_level,
                'message': self._generate_alert_message(
                    anomaly['sensor_id'], anomaly['location'], anomaly_type, 
                    base_level, confidence, anomaly['details']
                ),
                'recommendation': self._generate_recommendation(
                    anomaly['location'], anomaly_type, base_level, confidence
                )
            }
            
            alerts.append(alert)
        
        self.alerts = alerts
        return alerts
    
    def _generate_alert_message(self, sensor_id, location, anomaly_type, 
                               alert_level, confidence, details):
        """
        Generate an appropriate alert message.
        
        Args:
            sensor_id (int): ID of the sensor reporting the anomaly
            location (str): Location of the sensor
            anomaly_type (AnomalyType): Type of anomaly detected
            alert_level (AlertLevel): Level of alert
            confidence (float): Confidence score for the anomaly
            details (str): Additional details about the anomaly
            
        Returns:
            str: Alert message
        """
        # Get location description
        location_desc = self.location_names.get(location, "unknown tire location")
        
        # Format confidence as percentage
        confidence_pct = f"{confidence * 100:.0f}%"
        
        # Create appropriate prefix based on alert level
        if alert_level == AlertLevel.EMERGENCY:
            prefix = "EMERGENCY"
        elif alert_level == AlertLevel.CRITICAL:
            prefix = "CRITICAL ALERT"
        elif alert_level == AlertLevel.WARNING:
            prefix = "WARNING"
        elif alert_level == AlertLevel.ADVISORY:
            prefix = "ADVISORY"
        else:
            prefix = "INFO"
        
        # Construct message
        message = f"{prefix}: {anomaly_type.name} detected in {location_desc} " \
                  f"(Confidence: {confidence_pct}). {details}"
        
        return message
    
    def _generate_recommendation(self, location, anomaly_type, alert_level, confidence):
        """
        Generate a recommendation based on the anomaly.
        
        Args:
            location (str): Location of the sensor
            anomaly_type (AnomalyType): Type of anomaly detected
            alert_level (AlertLevel): Level of alert
            confidence (float): Confidence score for the anomaly
            
        Returns:
            str: Recommendation message
        """
        # Generate recommendations based on alert level and anomaly type
        if alert_level == AlertLevel.EMERGENCY:
            return "STOP VEHICLE IMMEDIATELY and inspect tire. Contact roadside assistance."
            
        elif alert_level == AlertLevel.CRITICAL:
            if anomaly_type == AnomalyType.SIDEWALL_DAMAGE:
                return "Reduce speed immediately. Schedule urgent tire replacement."
            elif anomaly_type == AnomalyType.BEAD_DAMAGE:
                return "Reduce speed and avoid sharp turns. Schedule urgent tire inspection."
            else:
                return "Reduce speed and schedule urgent tire inspection."
                
        elif alert_level == AlertLevel.WARNING:
            if anomaly_type == AnomalyType.TREAD_DAMAGE:
                return "Schedule tire inspection within next 100 miles."
            elif anomaly_type == AnomalyType.TEMPERATURE_ISSUE:
                return "Check tire pressure and reduce speed if temperature continues to rise."
            else:
                return "Schedule tire inspection at next opportunity."
                
        elif alert_level == AlertLevel.ADVISORY:
            if anomaly_type == AnomalyType.ACCELERATED_WEAR:
                return "Schedule regular tire maintenance. Consider tire rotation."
            elif anomaly_type == AnomalyType.UNEVEN_WEAR:
                return "Schedule tire rotation and alignment check."
            else:
                return "Monitor condition. Schedule regular maintenance."
                
        else:  # INFO level
            return "No immediate action needed. Continue regular tire maintenance."
    
    def visualize_data(self, output_dir='output'):
        """
        Create visualizations of the data and analysis results.
        
        Args:
            output_dir (str): Directory to save visualizations
            
        Returns:
            dict: Dictionary with file paths to generated visualizations
        """
        if self.normalized_data is None:
            print("No preprocessed data. Please preprocess data first.")
            return {}
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        visualizations = {}
        
        # 1. Plot impedance time series
        fig, ax = plt.subplots(figsize=(12, 6))
        
        for sensor_id in range(1, 5):
            normalized_col = f'sensor_{sensor_id}_normalized'
            location_col = f'sensor_{sensor_id}_location'
            
            if normalized_col in self.normalized_data.columns:
                # Get the location for this sensor
                location = self.normalized_data[location_col].iloc[0]
                label = self.location_names.get(location, location)
                
                # Plot normalized impedance
                ax.plot(self.normalized_data['timestamp'], 
                       self.normalized_data[normalized_col], 
                       'o-', label=f"Sensor {sensor_id} ({label})")
        
        # Add threshold line
        ax.axhline(y=1.3, color='red', linestyle='--', alpha=0.6, label='Alert Threshold')
        
        # Mark anomalies
        for anomaly in self.anomalies:
            ax.scatter(anomaly['timestamp'], anomaly['value'], 
                      marker='*', s=120, color='red', edgecolor='black', linewidth=1.5,
                      label='Anomaly' if 'anomaly_plotted' not in locals() else "")
            anomaly_plotted = True
        
        # Add labels and title
        ax.set_title('Tire Impedance Readings Over Time', fontsize=14)
        ax.set_xlabel('Time', fontsize=12)
        ax.set_ylabel('Normalized Impedance', fontsize=12)
        
        # Format the x-axis to show readable timestamps
        plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
        
        # Add grid and legend
        ax.grid(True, linestyle='--', alpha=0.7)
        handles, labels = ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        ax.legend(by_label.values(), by_label.keys(), loc='upper left')
        
        plt.tight_layout()
        
        # Save plot
        timestamp_str = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{output_dir}/impedance_time_series_{timestamp_str}.png"
        plt.savefig(filename)
        visualizations['impedance_time_series'] = filename
        plt.close(fig)
        
        # 2. Plot tire status visualization
        fig, ax = plt.subplots(figsize=(8, 8))
        
        # Set plot bounds
        ax.set_xlim(-1.2, 1.2)
        ax.set_ylim(-1.2, 1.2)
        
        # Draw tire outline
        tire_outline = Circle((0, 0), 1, fill=False, linewidth=2, color='black')
        ax.add_patch(tire_outline)
        
        # Draw rim
        rim = Circle((0, 0), 0.4, fill=True, color='lightgray', alpha=0.6)
        ax.add_patch(rim)
        
        # Draw tread area
        tread = Circle((0, 0), 1, fill=True, color='gray', alpha=0.2)
        ax.add_patch(tread)
        
        # Draw sensor positions and status
        sensor_positions = {
            1: (-0.5, 0.5),    # Tread left
            2: (0.5, 0.5),     # Tread right
            3: (0, 0.9),       # Sidewall
            4: (0, 0.4)        # Bead
        }
        
        # Get the last row of data for current status
        last_row = self.normalized_data.iloc[-1]
        
        for sensor_id in range(1, 5):
            normalized_col = f'sensor_{sensor_id}_normalized'
            location_col = f'sensor_{sensor_id}_location'
            
            if normalized_col in last_row and location_col in last_row:
                # Get normalized value for this sensor
                normalized_value = last_row[normalized_col]
                location = last_row[location_col]
                position = sensor_positions[sensor_id]
                
                # Check if anomaly was detected for this sensor
                has_anomaly = any(a['sensor_id'] == sensor_id for a in self.anomalies)
                
                # Set color based on normalized value and anomaly status
                if has_anomaly:
                    color = 'red'
                    size = 0.1
                else:
                    # Color gradient from green to yellow to red
                    if normalized_value < 1.1:
                        color = 'green'
                    elif normalized_value < 1.2:
                        color = 'yellow'
                    else:
                        color = 'orange'
                    size = 0.08
                
                # Draw sensor
                sensor = Circle(position, size, fill=True, color=color, alpha=0.8)
                ax.add_patch(sensor)
                
                # Add sensor label
                plt.text(position[0], position[1], str(sensor_id), 
                        ha='center', va='center', fontsize=10, color='white')
                
                # Add reading value near the sensor
                plt.text(position[0], position[1] - 0.15, f"{normalized_value:.2f}", 
                        ha='center', va='center', fontsize=8)
        
        # Add title and legend
        ax.set_title('Tire Status Visualization', fontsize=14)
        ax.axis('equal')
        ax.axis('off')
        
        # Add a legend
        legend_elements = [
            Circle((0, 0), 0.05, color='green', alpha=0.8),
            Circle((0, 0), 0.05, color='yellow', alpha=0.8),
            Circle((0, 0), 0.05, color='orange', alpha=0.8),
            Circle((0, 0), 0.05, color='red', alpha=0.8)
        ]
        
        legend_labels = [
            'Normal',
            'Caution',
            'Warning',
            'Anomaly Detected'
        ]
        
        ax.legend(legend_elements, legend_labels, loc='lower center', 
                 bbox_to_anchor=(0.5, -0.1), ncol=4)
        
        plt.tight_layout()
        
        # Save plot
        filename = f"{output_dir}/tire_status_{timestamp_str}.png"
        plt.savefig(filename)
        visualizations['tire_status'] = filename
        plt.close(fig)
        
        return visualizations
    
    def generate_report(self, output_dir='output'):
        """
        Generate a diagnostic report based on the analysis.
        
        Args:
            output_dir (str): Directory to save the report
            
        Returns:
            str: Path to the generated report file
        """
        if not self.alerts:
            print("No alerts available. Please generate alerts first.")
            return None
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # Count alerts by type and level
        alert_counts = {}
        level_counts = {}
        
        for alert in self.alerts:
            anomaly_type = alert['anomaly_type'].name
            alert_level = alert['alert_level'].name
            
            if anomaly_type not in alert_counts:
                alert_counts[anomaly_type] = 0
            alert_counts[anomaly_type] += 1
            
            if alert_level not in level_counts:
                level_counts[alert_level] = 0
            level_counts[alert_level] += 1
        
        # Generate report
        report = "TIRE MAINTENANCE REPORT\n"
        report += f"Generated: {datetime.now()}\n"
        report += f"Total alerts: {len(self.alerts)}\n\n"
        
        # Add alert statistics
        report += "Alert Statistics:\n"
        for anomaly_type, count in alert_counts.items():
            report += f"- {anomaly_type}: {count} alerts\n"
        
        report += "\nAlert Levels:\n"
        for level, count in level_counts.items():
            report += f"- {level}: {count} alerts\n"
        
        # Add recommendations based on alert history
        report += "\nMaintenance Recommendations:\n"
        
        if any(a['alert_level'] in [AlertLevel.EMERGENCY, AlertLevel.CRITICAL] 
              for a in self.alerts):
            report += "- URGENT: Immediate tire replacement recommended\n"
        elif any(a['alert_level'] == AlertLevel.WARNING for a in self.alerts):
            report += "- Schedule tire inspection within 1 week\n"
        elif any(a['alert_level'] == AlertLevel.ADVISORY for a in self.alerts):
            report += "- Schedule tire rotation and inspection at next service\n"
        else:
            report += "- Continue regular tire maintenance as scheduled\n"
        
        # Check for specific conditions
        if any(a['anomaly_type'] == AnomalyType.UNEVEN_WEAR for a in self.alerts):
            report += "- Wheel alignment check recommended\n"
        
        if any(a['anomaly_type'] == AnomalyType.TEMPERATURE_ISSUE for a in self.alerts):
            report += "- Tire pressure check recommended\n"
        
        # Add detailed alert log
        report += "\nDetailed Alert Log:\n"
        for alert in self.alerts:
            timestamp = alert['timestamp'].strftime('%Y-%m-%d %H:%M:%S')
            report += f"[{timestamp}] [{alert['alert_level'].name}] {alert['message']}\n"
            report += f"  Recommendation: {alert['recommendation']}\n\n"
        
        # Save report to file
        timestamp_str = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_path = f"{output_dir}/tire_diagnostic_report_{timestamp_str}.txt"
        
        with open(report_path, 'w') as f:
            f.write(report)
        
        print(f"Diagnostic report saved to: {report_path}")
        return report_path


def analyze_file(file_path, output_dir='output'):
    """
    Analyze a single data file.
    
    Args:
        file_path (str): Path to the data file
        output_dir (str): Directory to save output files
        
    Returns:
        tuple: (analyzer, report_path, visualizations)
    """
    print(f"Analyzing file: {file_path}")
    
    # Initialize analyzer
    analyzer = TireDataAnalyzer()
    
    # Load data
    analyzer.load_data(file_path)
    
    # Preprocess data
    analyzer.preprocess_data()
    
    # Detect anomalies
    anomalies = analyzer.detect_anomalies()
    
    # Generate alerts
    alerts = analyzer.generate_alerts()
    
    # Create visualizations
    visualizations = analyzer.visualize_data(output_dir)
    
    # Generate report
    report_path = analyzer.generate_report(output_dir)
    
    print(f"Analysis complete. Found {len(anomalies)} anomalies.")
    print(f"Generated {len(alerts)} alerts.")
    print(f"Generated {len(visualizations)} visualizations.")
    
    return analyzer, report_path, visualizations


def main():
    """Main function to analyze simulation data."""
    parser = argparse.ArgumentParser(
        description='Analyze tire impedance simulation data')
    
    parser.add_argument('--file', type=str,
                        help='Path to specific data file to analyze')
    parser.add_argument('--dir', type=str, default='data',
                        help='Directory containing simulation data files (default: data)')
    parser.add_argument('--output-dir', type=str, default='output',
                        help='Directory to save output files (default: output)')
    parser.add_argument('--latest', action='store_true',
                        help='Analyze only the latest data file')
    
    args = parser.parse_args()
    
    # Create output directory if it doesn't exist
    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)
    
    if args.file:
        # Analyze specific file
        analyze_file(args.file, args.output_dir)
    elif args.latest:
        # Find latest file in data directory
        data_files = glob.glob(f"{args.dir}/*.csv")
        
        if not data_files:
            print(f"No data files found in {args.dir}.")
            return
        
        # Find the most recently modified file
        latest_file = max(data_files, key=os.path.getmtime)
        print(f"Analyzing latest file: {latest_file}")
        analyze_file(latest_file, args.output_dir)
    else:
        # Analyze all files in directory
        data_files = glob.glob(f"{args.dir}/*.csv")
        
        if not data_files:
            print(f"No data files found in {args.dir}.")
            return
        
        for file_path in data_files:
            analyze_file(file_path, args.output_dir)


if __name__ == "__main__":
    print("=" * 80)
    print("Tire Impedance Data Analyzer")
    print("Based on Ucaretron Inc. patent application")
    print("=" * 80)
    print("\nUSAGE EXAMPLES:")
    print("  python analyze_simulation_data.py")
    print("  python analyze_simulation_data.py --file data/sidewall_damage_data_20250507_080000.csv")
    print("  python analyze_simulation_data.py --latest")
    print("-" * 80)
    
    main()
